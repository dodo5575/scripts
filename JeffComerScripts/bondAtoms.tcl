# Bond atoms nearer than a given distance.
# to use: vmd -dispdev text -e bondAtoms.tcl
# Author: Jeff Comer <jcomer2@illinois.edu>

# Input:
set pdb0 water_slab1a.pdb
# Output:
set psf water_slab1b.psf

# Periodic box parameters:
# Make them huge to avoid image bonding along a given axis.
# For example, "set bz 1000000" to avoid periodicity along z.
set bx 150.
set by 150.
set bz 1000000.

# Parameters:
# Bond all atoms nearer than "dist".
set dist 6.0
set type P
set charge "  0.000000"
set mass "       72.0000"

proc main {} {
	global pdb0 pdb psf
	global dist
	global type mass charge
	global bx by bz
	
	puts "Beginning bondAtoms..."
	
	# Obtain the atom positions.
	puts "Getting the atom positions..."
	set r [extractCoords $pdb0]
	set n [llength $r]
	puts "Found the positions of $n atoms"
	
	# Determine the bonds.
	puts "Determining the bonds..."
	set bond [bondAtoms $r $dist [list $bx $by $bz]]
	#set bond {}
	set totalBonds [llength $bond]
	puts "Found $totalBonds bonds."
	
	# Write the psf file.
	puts "Writing psf file..."
	set out [open $psf w]
	puts "Writing atom records..."
	writeAtomRecords $out [extractAttributes $pdb0] $type $charge $mass
	puts "Writing the bonds..."
	writeBonds $out $bond
	puts "Finishing the psf..."
	writeTheRest $out $n
	puts "The psf file was written successfully."

	close $out
}

# Create a bond list, bonding all atoms within "dist".
proc bondAtoms {r dist box} {
	set n [llength $r]
	set n1 [expr $n-1]
	set dsq [expr $dist*$dist]
	
	set lx [expr 0.5*[lindex $box 0]]
	set ly [expr 0.5*[lindex $box 1]]
	set lz [expr 0.5*[lindex $box 2]]
	
	# Check all pairs.
	set bond {}
	for {set i 0} {$i < $n1} {incr i} {
		if {[expr $i % 10 == 0]} {puts "primary index: $i/$n"}
		for {set j [expr $i+1]} {$j < $n} {incr j} {
			set dx [expr [lindex $r $j 0]-[lindex $r $i 0]]
			set dy [expr [lindex $r $j 1]-[lindex $r $i 1]]
			set dz [expr [lindex $r $j 2]-[lindex $r $i 2]]
			
			# Wrap to the periodic image.
			if {[expr $dx > $lx]} {set dx [expr $dx-2.*$lx]}
			if {[expr $dy > $ly]} {set dy [expr $dy-2.*$ly]}
			if {[expr $dz > $lz]} {set dz [expr $dz-2.*$lz]}
			if {[expr $dx < -$lx]} {set dx [expr $dx+2.*$lx]}
			if {[expr $dy < -$ly]} {set dy [expr $dy+2.*$ly]}
			if {[expr $dz < -$lz]} {set dz [expr $dz+2.*$lz]}
						
			if {[expr $dx*$dx + $dy*$dy + $dz*$dz] <= $dsq} {
				lappend bond [list [expr $i+1] [expr $j+1]]
			}
		}
	}
	
	return $bond
}
	
# Returns a list with atom positions.
proc extractCoords {pdbFile} {
	set r {}
	
	# Get the coordinates from the pdb file.
	set in [open $pdbFile r]
	foreach line [split [read $in] \n] {
		if {[string equal [string range $line 0 3] "ATOM"]} {
			set x [string trim [string range $line 30 37]]
			set y [string trim [string range $line 38 45]]
			set z [string trim [string range $line 46 53]]
			
			lappend r [list $x $y $z]
		}
	}
	close $in
	return $r
}

# Returns a list with elements {name resid segname resname}.
proc extractAttributes {pdbFile} {
	set r {}
	
	# Get the coordinates from the pdb file.
	set in [open $pdbFile r]
	foreach line [split [read $in] \n] {
		if {[string equal [string range $line 0 3] "ATOM"]} {
			set name [string trim [string range $line 12 15]]
			set resid [string trim [string range $line 22 25]]
			set segname [string trim [string range $line 72 75]]
			set resname [string trim [string range $line 17 19]]
			
			lappend r [list $segname $resid $resname $name]
		}
	}
	close $in
	return $r
}

proc writeAtomRecords {out attrib type charge mass} {
	set dummy "           0"
	set n [llength $attrib]

	# Write the header.
	puts $out "PSF"
	puts $out ""
	puts $out "       2 !NTITLE"
	puts $out " REMARKS structure x-plor psf file"
	puts $out " REMARKS generated by bondAtoms.tcl by Jeff Comer"

	##### ATOMS
	puts $out ""
	puts $out "[format %8i $n] !NATOM"

	set i 1
	foreach atom $attrib {
		foreach {segname resid resname name} $atom {break}
		
		puts -nonewline $out [format "%8i " $i]
		puts -nonewline $out [format "%-4s " $segname]
		puts -nonewline $out [format "%-4i " $resid]
		puts -nonewline $out [format "%-4s " $resname]
		puts -nonewline $out [format "%-4s " $name]
		puts -nonewline $out [format "%-4s " $type]
		puts -nonewline $out $charge
		puts -nonewline $out $mass
		puts $out $dummy
		
		incr i
	}
	puts $out ""
}

proc writeBonds {out bond} {
	# Write the bonds.
	set total [format %8i [llength $bond]]
	puts $out "$total !NBOND: bonds"
	set count 0
	foreach b $bond {
		puts -nonewline $out [format "%8i%8i" [lindex $b 0] [lindex $b 1]]
	
		incr count
		if {$count == 4} {
			puts $out ""
			set count 0
		}
	}
	puts $out ""
}

proc writeTheRest {out n} {
	# Write the angles.
	set totalAngles 0
	puts $out ""
	puts $out "[format %8i $totalAngles] !NTHETA: angles"
	puts $out ""

	# Write everything else.
	##### DIHEDRALS
	set nDihedrals 0
	puts $out ""
	puts $out "[format %8i $nDihedrals] !NPHI: dihedrals"
	puts $out ""

	##### IMPROPERS
	set nImpropers 0
	puts $out ""
	puts $out "[format %8i $nImpropers] !NIMPHI: impropers"
	puts $out ""

	##### DONORS
	set nDonors 0
	puts $out ""
	puts $out "[format %8i $nDonors] !NDON: donors"
	puts $out ""

	##### ACCEPTORS
	set nAcceptors 0
	puts $out ""
	puts $out "[format %8i $nAcceptors] !NACC: acceptors"
	puts $out ""

	##### NON-BONDED
	set nNB 0
	puts $out ""
	puts $out "[format %8i $nNB] !NNB"
	puts $out ""

	set tmp [expr int($n/8)]
	set tmp2 [expr $n -$tmp*8]
	for {set i 0} {$i <$tmp} {incr i} {
		puts $out "       0       0       0       0       0       0       0       0"
	}
	set lastString ""
	for {set i 0} {$i <$tmp2} {incr i} {
		set lastString "${lastString}       0"
	}
	puts $out $lastString

	####### GROUPS
	puts $out ""
	puts $out "       1       0 !NGRP"
	puts $out "       0       0       0"
	puts $out ""
	puts $out ""
}

main
exit





